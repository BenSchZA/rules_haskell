"""Workspace rules (Nixpkgs)"""

load("@bazel_skylib//lib:dicts.bzl", "dicts")
load(
    "@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl",
    "nixpkgs_package",
)

def haskell_nixpkgs_package(
        name,
        attribute_path,
        nix_file_deps = [],
        repositories = {},
        build_file_content = None,
        build_file = None,
        **kwargs):
    """Load a single haskell package.
    The package is expected to be in the form of the packages generated by
    `genBazelBuild.nix`
    """
    repositories = dicts.add(
        {"bazel_haskell_wrapper": "@io_tweag_rules_haskell//haskell:nix/default.nix"},
        repositories,
    )

    nixpkgs_args = dict(
        name = name,
        attribute_path = attribute_path,
        build_file_content = build_file_content,
        nix_file_deps = nix_file_deps + ["@io_tweag_rules_haskell//haskell:nix/default.nix"],
        repositories = repositories,
        **kwargs
    )

    if build_file_content:
        nixpkgs_args["build_file_content"] = build_file_content
    elif build_file:
        nixpkgs_args["build_file"] = build_file
    else:
        nixpkgs_args["build_file_content"] = """
package(default_visibility = ["//visibility:public"])
load("@io_tweag_rules_haskell//haskell:import.bzl", haskell_import_new = "haskell_import")

load(":BUILD.bzl", "targets")
targets()
"""

    nixpkgs_package(
        **nixpkgs_args
    )

def _ghc_nixpkgs_toolchain_impl(repository_ctx):
    nixpkgs_ghc_path = repository_ctx.path("../../external/io_tweag_rules_haskell_ghc-nixpkgs")

    # Symlink content of ghc external repo. In effect, this repo has
    # the same content, but with a BUILD file that includes generated
    # content (not a static one like nixpkgs_package supports).
    for target in _find_children(repository_ctx, nixpkgs_ghc_path):
        basename = target.rpartition("/")[-1]
        repository_ctx.symlink(target, basename)

    repository_ctx.file(
        "BUILD",
        executable = False,
        content = """
load(
    "@io_tweag_rules_haskell//haskell:haskell.bzl",
    "haskell_import",
    "haskell_toolchain",
)

haskell_import(
    name = "rts",
    id = "rts",
    shared_library = 'lib/ghc-8.6.4/rts/libHSrts-ghc*.so',
    static_library = 'lib/ghc-8.6.4/rts/libHSrts.a',
    version = "1.0",
    visibility = ["//visibility:public"],
)

haskell_toolchain(
    name = "toolchain",
    libraries = [":rts"],
    version = "{version}",
)
        """.format(
            version = repository_ctx.attr.version,
        ),
    )

_ghc_nixpkgs_toolchain = repository_rule(
    _ghc_nixpkgs_toolchain_impl,
    local = False,
    attrs = {
        # These attributes just forward to haskell_toolchain.
        # They are documented there.
        "version": attr.string(),
    },
)

def haskell_register_ghc_nixpkgs(
        version,
        build_file = None,
        compiler_flags = None,
        compiler_flags_select = None,
        haddock_flags = None,
        repl_ghci_args = None,
        locale_archive = None,
        attribute_path = "haskellPackages.ghc",
        nix_file = None,
        nix_file_deps = [],
        repositories = {}):
    """Register a package from Nixpkgs as a toolchain.

    Toolchains can be used to compile Haskell code. To have this
    toolchain selected during [toolchain
    resolution][toolchain-resolution], set a host platform that
    includes the `@io_tweag_rules_haskell//haskell/platforms:nixpkgs`
    constraint value.

    [toolchain-resolution]: https://docs.bazel.build/versions/master/toolchains.html#toolchain-resolution

    Example:

      ```
      haskell_register_ghc_nixpkgs(
          locale_archive = "@glibc_locales//:locale-archive",
          atttribute_path = "haskellPackages.ghc",
          version = "1.2.3",   # The version of GHC
      )
      ```

      Setting the host platform can be done on the command-line like
      in the following:

      ```
      --host_platform=@io_tweag_rules_haskell//haskell/platforms:linux_x86_64_nixpkgs
      ```

    """
    haskell_nixpkgs_package(
        name = "io_tweag_rules_haskell_ghc-nixpkgs",
        attribute_path = attribute_path,
        build_file = build_file or "@io_tweag_rules_haskell//haskell:ghc.BUILD",
        nix_file = nix_file,
        nix_file_deps = nix_file_deps,
        repositories = repositories,
    )
    _ghc_nixpkgs_toolchain(
        name = "io_tweag_rules_haskell_ghc-nixpkgs-toolchain",
        version = version,
    )
    native.register_toolchains("@io_tweag_rules_haskell_ghc-nixpkgs-toolchain//:toolchain")

def _find_children(repository_ctx, target_dir):
    find_args = [
        "find",
        "-L",
        target_dir,
        "-maxdepth",
        "1",
        # otherwise the directory is printed as well
        "-mindepth",
        "1",
        # filenames can contain \n
        "-print0",
    ]
    exec_result = repository_ctx.execute(find_args)
    if exec_result.return_code: fail("_find_children() failed.")
    return exec_result.stdout.rstrip("\0").split("\0")
